# C++进阶(20) 多重继承

C++是否允许一个类继承多个父类？可以的。

## 20.1 多重继承的问题

### 20.1.1  同一个对象的指向的地址可能不同

- 一个子类可以拥有多个父类
- 子类拥有父类的所有成员变量
- 子类继承父类所有的成员函数
- 子类对象可以作为任意父类来使用

```C++
class Derived : public BaseA,
			   public BaseB,
			   public BaseC{
                   
               };
```

> 实验20-1 多重继承
>
> - 多重继承的大小
> - 子类中无法访问父类的私有成员
> - 两个父类指向同一个子类，其地址不同

通过多重继承得到的对象，可以拥有不同的地址。

```C++
Derived d(1, 2, 3);
BaseA* pa = &d;
BaseB* pb = &d;
```

pa 与 pb 仍指向同一个对象，但指向的对象地址不同。

在判断同一个对象时，对象地址相同即可，但多重继承下，无法判断是否是同一个对象。



### 20..1.2 多重继承可能产生冗余的成员

> 实验20-2 多重继承产生冗余成员，需要用作用域指示符确定调用哪一个函数

解决方案：虚继承

```C++
class People{};
class Teacher: virtual People{};
class Student: virtual People{};
class Doctor:  public Teacher, public Student{};
```

- 虚继承可以解决冗余数据的问题
- 中间层父类不再关心顶层父类的初始化
- 最终子类必须直接调用顶层父类的构造函数

> 实验20-2 多重继承的冗余成员问题及虚函数解决方案 

</br>

### 20.1.3 多重继承可能产生多个虚函数表

> 实验20-3 多个虚函数表，不同子类指向同一个父类，在进行类型转换时，可能会出现调用其他子类的情况。

解决方案：使用 `dynamic_cast` 类型转换



</br>

## 20.2 正确使用多继承

工程开发中，多重继承的方式：单继承某个类 + 实现多个接口

> 实验20-4 单继承+多接口

- 先继承一个父类，然后实现多个接口
- 父类中提供 `equal` 成员函数
- `equal()` 成员函数用于判断指针是否指向当前对象
- 与多重继承相关的强制类型转换用 `dynamic_cast` 完成