# C++进阶(16) 继承

## 16.1 继承与组合

类之间是否存在直接的关联关系？

- 组合关系
- 继承

组合关系特点：

1. 将其他类的对象作为其他类成员使用
2. 当前类对象与成员对象的生命周期相同
3. 成员对象在用法上与普通对象完全一致

继承关系的特点：

1. 子类拥有父类的所有属性和行为   
2. 子类是一种特殊的父类
3. 子类对象可以看做父类对象使用
4. 子类可以添加父类中没有的方法和属性

> 实验16-1 ： 子类有父类的成员函数，包含父类的构造函数
>
> 实验16-2：继承的第二个示例

继承的意义：

继承是C++中代码复用的重要手段。通过继承，子类获得父类所有功能，并且可以在子类中重写已有功能，或者添加新的功能。

</br>

## 16.2 继承的访问级别

- public继承： 父类成员在子类中保持原有访问级别

- private继承：父类成员在子类中变为私有成员

- protected继承：父类的公有成员变为保护成员，其他成员保持不变。

  > 继承成员访问属性 = Max {继承方式，父类成员访问属性}
  >
  > private > protected > public

  在 C++ 中，继承默认为 private 继承。

> 实验16-3 ： 继承的访问级别。

</br>

## 16.3 构造与析构

### 16.3.1 父类与子类的构造

父类构造函数与子类构造函数的关系？

子类对于继承的父类，必须进行初始化。在构造子类时，会先构造父类，在构造子类。构造父类有两种方式：

1. 直接赋值
2. 调用父类构造函数

- 默认调用（无参构造 / 使用默认参数的构造函数）
- 显式调用（初始化列表 ）

> 实验16-4 子类初始化父类

</br>

### 16.3.2 构造函数的顺序

对象创建时，构造函数的调用顺序：

1. 调用父类的构造函数
2. 调用成员变量的构造函数
3. 调用类自身的构造函数

> 先父母，后客人，再自己。

> 实验16-5 构造函数的调用顺序

</vr>

### 16.3.3 析构函数的调用顺序

析构函数的调用顺序与构造函数相反：

1. 自身的析构函数
2. 成员的析构函数
3. 父类的析构函数

> 实验16-6 析构函数的调用顺序

## 16.4 同名成员

### 16.4.1 成员变量

子类中是否可以定义父类的同名成员？

- 子类可以定义父类的同名成员
- 子类成员将隐藏父类中的同名成员
- 父类的同名成员依然存在于子类中
- 通过作用域分辨符（::) 访问父类同名成员，如 `c.Parent::mi`

> 16-7 成员变量的同名冲突

### 16.4.2 成员函数

 子类中定义的函数是否可以重载父类中同名函数？

- 子类函数会隐藏父类的同名函数
- 子类无法重载父类的成员函数
- 使用作用域分辨符访问父类的同名函数
- 子类可以定义父类完全相同的成员函数

函数重载必须出现在同一作用域中。当父类与子类含有相同名称的函数时，不是函数重载，调用父类的函数时，需要使用作用域分辨符。

> 16-8 成员函数的同名冲突

</br>

## 16.5 同名覆盖问题

### 16.5.1 赋值兼容

子类对象可以作为父类对象使用：

- 子类对象可以直接赋值给父类对象
- 子类对象可以直接初始化父类对象
- 父类指针可以直接指向子类对象
- 父类引用可以直接引用子类对象

父子间的赋值兼容：

当父类对象指针（引用）指向子类对象时：

- 子类对象退化为父类对象
- 只能访问父类中定义的成员
- 可以直接访问被子类覆盖的同名成员函数

> 实验16-9 父类指针 / 引用指向子类

### 16.5.2 函数重写

子类重定义父类中定义的成员函数，在继承中，成为函数重写。函数重写是同名覆盖的一种特殊情况。

函数重写遇到赋值兼容会发生什么？

> 实验16-10 子类重写父类函数

```C++
void how_to_print(Parent* p)
{
    p->print();
}

```

编译器在编译时，无法知道指针p指向的对象是子类对象还是父类对象。编译器认为安全的做法是调用父类的print函数，因为父类和子类都有相同的print函数





