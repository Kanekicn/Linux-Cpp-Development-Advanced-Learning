# C++进阶(27) 类型识别

在面向对象中，有父子兼容性原则：

- 基类指针指向子类对象
- 基类引用成为子类对象的别名

> Base* p = new Derived();
>
> Base& r = *p;
>
> 其中，Base为静态类型（指针期望的类型），Derived为动态类型（在运行时确定）。

静态类型：变量（对象）自身的类型

动态类型：指针（引用）所指向对象的实际类型。

 C++中如何得到对象的动态类型？



## 27.1 动态类型识别

利用多态识别动态类型：

1. 在基类中定义虚函数返回具体的类型信息
2. 所有派生类都必须实现类型相关的虚函数
3. 每个类中的类型虚函数都需要不同的实现。

> 实验27-1 动态类型转换，static_cast , dynamic_cast

多态解决的缺陷：

1. 必须从基类开始提供虚函数
2. 所有派生类都必须重写类型虚函数
3. 每个派生类的类型名必须唯一



## 27.2 typeid

C++中提供了 `typeid` 关键字用于获取类型信息。

- `typeid` 关键字返回对应参数的类型信息
- `typeid` 返回一个 `type_info` 类对象
- 当 `typeid` 参数为 `nullptr` 时将抛出异常

使用 ：

```C++
int i = 0;

const type_info& tiv = typeid(i);
const type_info& tii = typeid(int);

cout << (tiv == tii) << endl;
```

返回值：

- 参数为类型时，返回静态类型信息
- 参数为变量时
  - 不存在虚函数表时，返回静态类型信息
  - 存在虚函数表时，返回动态类型信息

> 实验27-2 `typeid` 关键字的使用













