# C++进阶(21) 函数模板

C++中交换变量有几种方法？

1. 定义宏定义，宏在预处理时进行展开。
2. 函数定义

```C++
#define SWAP(t, a, b)    \
do                       \
{                        \
    t c = a;             \
    a = b;               \
    b = c;               \
}while(0)
```



定义宏代码块：

优点： 代码复用，适合所有类型

缺点：编译器不知道宏的存在，缺少类型检查

定义函数：

优点： 真正的函数调用，编译器对类型进行检查

缺点：根据类型重复定义函数，无法代码复用

## 21.1 泛型编程

泛型编程是不考虑数据类型的编码方式。

```C++
void swap(T& a, T& b){
    T tmp = a;
    a = b;
    b = tmp;
}
```

通过函数模板和类模板来进行泛型编程。函数模板是一种特殊的函数，可用不同类型进行调用。与普通函数相比，其类型可以被参数化。语法规则如下

- template ： 表示开始泛型编程
- typename:  用于声明泛指类型

```C++
template <typename T> 
void swap(T& a, T& b){
    T tmp = a;
    a = b;
    b = tmp;
}
```

函数模板的使用的两种方式：

1. 自动类型推导调用  ： `Swap(a, b)`
2. 具体类型显式调用  :   `Swap<int> (a, b)`

函数模板的意义：

- 函数模板可以根据泛型编程在C++中应用方式之一
- 函数模板根据实参对类型进行推导
- 函数模板支持显式制定参数类型
- 函数模板是C++中重要的代码复用方式

</br>

## 21.2 函数模板编译

函数模板在编译时，

- 编译器从函数模板通过具体类型产生不同的函数
- 编译器会对函数模板进行两次编译：首先对模板代码本身进行编译（语法检查），然后对参数替换后的代码进行编译

注意事项：函数模板不允许隐式类型转换，在自动推导时，必须严格匹配；显式制定类型时，可以进行隐式类型转换

> 实验21-3 函数模板编译过程

</br>

## 21.3 多参数函数模板

函数模板可以定义任意多个不同类型的参数

```C++
template
<typename T1, typename T2, typename T3>
T1 add(T2 a, T3 b){
	return static_cast<T1> (a+b);
}
```

对于多参数函数模板，

- 返回值：无法自动推导出返回值类型，必须显式制定返回值类型
- 参数：可以指定，编译器会从左向右制定类型参数

> 工程中将返回值参数作为第一个类型参数。

</br>

## 21.4 函数模板与函数重载

函数模板可以与普通函数一样被重载。匹配规则如下：

- C++编译器优先考虑普通函数
- 如果函数模板可以产生一个更好的匹配，则选择模板函数
- 通过空参数模板实参列表，限定编译器只匹配模板

> 实验21-5 函数模板重载