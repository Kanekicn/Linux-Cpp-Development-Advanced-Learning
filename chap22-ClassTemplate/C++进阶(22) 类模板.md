# C++进阶(22) 类模板

## 22.1 类模板

一些类主要用于存储和组织数据元素。其数据组织方式与数据元素的具体类型无关，所以可以通过类模板来进行coding。如数组类，链表类，Stack类，Queue类等。

通过类模板，使得类的实现**不关注** 数据元素的 **具体类型** ，而只关注类需要**实现的功能** 。

C++中类模板用法如下

```C++
template <typename T>
class Operator{
public:
    T op(T a, T b);
}
```

</br>

类模板与函数模板不同，类模板**只能显式** 指定具体的类型，无法自动推导。通过具体类型 `<Type>` 来定义对象。

```C++
Operator<int> op1;
Operator<string> op2;

int i = op1.op(1, 2);
```

</br>

编译器如何处理类模板？

编译器处理类模板的方式与函数模板相同，对模板进行编译一次，在使用时，代替具体类型再编译一次：

- 从类模板通过具体类型产生不同的类
- 在声明的地方对类模板本身进行编译
- 在使用的地方对参数替换后的代码进行编译

## 22.2 应用

类模板的工程应用：

- 类模板必须在头文件中定义
- 类模板不能分开实现在不同的文件中
- 类模板外部定义的成员函数需要加上 **模板<>** 声明

本节展示泛型编程思想可以应用于类，其类模板使用与编写数据结构相关代码，使得代码复用。值得注意的是，类模板不同于函数模板，在使用时必须显式指定类型。

> 实验22-2 类模板的编写

</br>

## 22.3 多参数类模板

类模板可以指定任意多个不同的类型参数

```C++
template
<Typename T1, Typename T2>
class Test{
public:
	void add (T1 a, T2, b);
}

// 使用
Test<int , float>
```

</br>

类模板特殊的性质：

类模板可以被特化：

- 指定类模板的特定实现
- 部分类型参数必须显式指定
- 根据类型参数分开实现类模板

一个类模板可以分开实现为两种，一种是普通版本，一种是特化版本，编译器会根据实际使用的普通版本还是特化版本。

```C++
template
<typename T1, typename T2>
class Test{

}
```

特化版本

```C++
tempalte
<typename T>
class <T, T>{
    
}
```



特化分为：部分特化和完全特化。

完全特化

```C++
template
<   >
class Test<int, int>{
    
}
```

> 实验22-3 类模板特化 部分特化， 完全特化

</br>

## 22.4 模板特化

类模板特化的注意事项：

- 特化只是模板的分开实现，本质是同一个类模板
- 特化类模板的使用方式是同一的，必须指定每一个类型参数



类模板特化与重定义区别？

重定义是指定义一个类模板和一个新类，在使用时考虑如何选择的问题。

特化是以统一的方式使用类模板和特化类，编译器自动选择特化类。

函数模板可以特化么？

函数模板支持特化，但只支持完全特化。

> 实验22-4 函数模板的完全特化  V.S 函数重载

> 当需要重载函数模板时，优先考虑模板特化。
>
> 当模板特化无法满足需求，在考虑函数重载。



















